## 方針
まずソースコードをみると、win関数があり、そこでシェルを起動していることがわかる。main関数からwin関数は呼び出されていないため、バッファオーバーフローによるリターンアドレスの書き換えで、シェルを起動されることを目標にする。

しかし、セキュリティ機構を確認すると以下のようになる。
```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
stackの欄からcanaryが有効である。これは、配布ファイルを実行した際に出力されるスタックの様子からもわかるが、ローカル変数とリターンアドレスの間にcanaryという変数が格納された領域が存在する。
これは、関数終了時に値が書き変わっていないことを確認する、バッファオーバーフローの対策である。つまり、リターンアドレスを書き換える前後でcanaryの値を変えてはいけない。

そこで、今回は2回ある入力受付で、
1. canaryを取得
1. リターンアドレスの書き換えを目指す

## 分析
canaryの特徴として、先頭1byteは0x00となっている。これはprintfなどの出力で、前の文字列と合わせて出力されてしまうのを防ぐためである。逆に、ここを何か別に書き換えることによって、bufの中身と合わせて出力させることができる。

これを受け取り、2回目の入力でcanaryを含めたpayloadを作成し、リターンアドレスを書き換えることができる。
